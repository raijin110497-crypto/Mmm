<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>MMM Fingers - Vanilla</title>
  <meta name="theme-color" content="#59b6ff" />
  <style>
    :root {
      --sky-1: #b9e6ff;
      --sky-2: #69c3ff;
      --fg: #0a1830;
      --muted: #2c476e;
      --accent: #34d06b;
      --danger: #ff4d4f;
      --warning: #ffcc00;
      --shadow: rgba(0,0,0,.45);
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: linear-gradient(180deg, var(--sky-1), var(--sky-2));
      color: var(--fg);
      font: 400 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overscroll-behavior: none;
      touch-action: none;
    }

    .game-root { position: fixed; inset: 0; display: grid; grid-template-rows: 1fr; }
    .game-canvas { width: 100%; height: 100%; display: block; touch-action: none; }

    .hud { position: fixed; inset: env(safe-area-inset-top) 0 auto 0; display: flex; justify-content: space-between; align-items: center; padding: 10px 14px; pointer-events: none; }
    .scorebox { display: inline-flex; gap: 10px; align-items: center; background: rgba(255,255,255,.25); padding: 8px 12px; border-radius: 999px; box-shadow: 0 6px 16px var(--shadow) inset, 0 2px 10px var(--shadow); backdrop-filter: blur(6px); }
    .score { font-weight: 800; letter-spacing: .5px; }
    .hi { color: var(--muted); font-size: 14px; }

    .overlay { position: fixed; inset: 0; display: grid; place-items: center; padding: 24px; background: radial-gradient(1200px 800px at 50% 0%, rgba(0,0,0,.12), rgba(0,0,0,.18)); }
    .panel { width: min(520px, 92vw); background: rgba(255,255,255,.7); border: 1px solid rgba(0,0,0,.06); border-radius: 16px; box-shadow: 0 10px 30px var(--shadow); padding: 20px; text-align: center; backdrop-filter: blur(8px); }
    .title { font-size: 30px; margin: 6px 0 2px; font-weight: 900; letter-spacing: .4px; color: #0a1830; }
    .subtitle { margin: 0 0 12px; color: var(--muted); }
    .pill-list { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin: 12px 0 18px; }
    .pill { font-size: 13px; color: #0b220f; background: #c6f7ce; border: 1px solid #9ee8ad; border-radius: 999px; padding: 6px 10px; }
    .btn-row { display: flex; gap: 12px; justify-content: center; }
    .btn { appearance: none; border: none; border-radius: 12px; padding: 12px 16px; font-weight: 800; letter-spacing: .3px; cursor: pointer; box-shadow: 0 10px 20px var(--shadow), inset 0 -2px 0 rgba(0,0,0,.25); }
    .btn-primary { background: linear-gradient(180deg, #6be675, #3bcf59); color: #0b220f; }
    .btn-ghost { background: rgba(255,255,255,.8); color: var(--fg); border: 1px solid rgba(0,0,0,.12); }

    .toast-stack { position: fixed; right: 14px; bottom: calc(14px + env(safe-area-inset-bottom)); display: grid; gap: 8px; z-index: 2; }
    .toast { background: rgba(0,0,0,.6); color: #fff; border: 1px solid rgba(255,255,255,.08); padding: 10px 12px; border-radius: 12px; box-shadow: 0 8px 18px var(--shadow); animation: pop .22s ease-out; }

    @keyframes pop { from { transform: translateY(8px) scale(.98); opacity: 0; } to { transform: translateY(0) scale(1); opacity: 1; } }

    .finger-badge { position: fixed; inset: auto 50% calc(20px + env(safe-area-inset-bottom)) auto; transform: translateX(50%); color: var(--muted); font-size: 13px; text-align: center; opacity: .85; pointer-events: none; }

    @media (max-width: 360px) { .title { font-size: 26px; } .pill { font-size: 12px; } }
  </style>
</head>
<body>
  <div class="game-root">
    <canvas class="game-canvas" id="game"></canvas>
  </div>

  <audio id="bgMusic" src="https://cdn.builder.io/o/assets%2Fee9df2374f664361817b4952e9f85c29%2Fafc90593f87f4cfcba88a8baf0597ad6?alt=media&token=e3fd7c16-c9a1-4560-b2db-bc0907a0085c&apiKey=ee9df2374f664361817b4952e9f85c29" preload="auto" loop playsinline style="position:absolute;left:-9999px;width:0;height:0;opacity:0"></audio>

  <div class="hud" id="hud">
    <div class="scorebox">
      <span class="score" id="score">0.00s</span>
      <span class="hi" id="hi">Best: 0.00s</span>
    </div>
  </div>

  <div class="overlay" id="startOverlay" aria-hidden="false">
    <div class="panel">
      <div class="title">MMM Fingers</div>
      <p class="subtitle">Hold to play. Mario-like vibes. Avoid the chompers!</p>
      <div class="pill-list">
        <span class="pill">One-touch</span>
        <span class="pill">Endless</span>
        <span class="pill">Local highscores</span>
        <span class="pill">Mobile ready</span>
      </div>
      <div class="btn-row">
        <button class="btn btn-primary" id="tapToStart">Hold to Play</button>
        <button class="btn btn-ghost" id="howToPlay">How to play</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="gameOverOverlay" aria-hidden="true" style="display:none">
    <div class="panel">
      <div class="title">Chomp! Game Over</div>
      <p class="subtitle" id="finalScore">You survived 0.00s</p>
      <div class="btn-row">
        <button class="btn btn-primary" id="retryBtn">Hold to Retry</button>
        <button class="btn btn-ghost" id="shareBtn">Share</button>
      </div>
    </div>
  </div>

  <div class="toast-stack" id="toasts" aria-live="polite" aria-atomic="true"></div>
  <div class="finger-badge">Touch & hold anywhere</div>

  <script>
  (function() {
    'use strict';

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const RAIL_W = 26;

    const hudScore = document.getElementById('score');
    const hudHi = document.getElementById('hi');
    const startOverlay = document.getElementById('startOverlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const finalScore = document.getElementById('finalScore');
    const tapToStart = document.getElementById('tapToStart');
    const howToPlay = document.getElementById('howToPlay');
    const retryBtn = document.getElementById('retryBtn');
    const shareBtn = document.getElementById('shareBtn');
    const toasts = document.getElementById('toasts');
    const bgMusic = document.getElementById('bgMusic');

    const store = {
      get(key, fallback) {
        try { const v = JSON.parse(localStorage.getItem(key)); return v ?? fallback; } catch { return fallback; }
      },
      set(key, val) { try { localStorage.setItem(key, JSON.stringify(val)); } catch {}
      }
    };

    const audio = {
      ctx: null,
      init() { try { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) {} },
      beep(freq, dur, type, vol) {
        try {
          this.init(); if (!this.ctx) return; const ctx = this.ctx;
          const t0 = ctx.currentTime; const o = ctx.createOscillator(); const g = ctx.createGain();
          o.type = type || 'sine'; o.frequency.setValueAtTime(freq || 440, t0);
          g.gain.setValueAtTime(vol ?? 0.08, t0); g.gain.exponentialRampToValueAtTime(0.0001, t0 + (dur || 0.08));
          o.connect(g); g.connect(ctx.destination); o.start(); o.stop(t0 + (dur || 0.08));
        } catch(e) {}
      },
      hit() { this.beep(160, 0.12, 'square', 0.18); this.beep(110, 0.18, 'square', 0.18); },
      start() { this.beep(660, 0.06, 'triangle', 0.1); this.beep(880, 0.06, 'triangle', 0.1); },
      ach() { this.beep(780, 0.08, 'triangle', 0.1); this.beep(980, 0.12, 'triangle', 0.1); }
    };

    const state = {
      running: false,
      dead: false,
      startTime: 0,
      elapsed: 0,
      best: store.get('mmm.best', 0),
      achievements: store.get('mmm.ach', {}),
      finger: { x: 0, y: 0, r: 18, alive: false, trailX: 0, trailY: 0 },
      trail: [],
      enemies: [],
      obstacles: [],
      entities: [],
      spawnTimer: 0,
      waveTimer: 0,
      nextWaveIn: 0,
      bgScrollY: 0,
      bgSpeed: 120,
      lastFrame: 0,
      touchActive: false
    };

    function resize() {
      const { clientWidth: w, clientHeight: h } = canvas;
      dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function fitCanvas() { canvas.style.width = '100%'; canvas.style.height = '100%'; resize(); }
    window.addEventListener('resize', resize);
    fitCanvas();

    function show(el) { el.style.display = 'grid'; el.setAttribute('aria-hidden', 'false'); }
    function hide(el) { el.style.display = 'none'; el.setAttribute('aria-hidden', 'true'); }

    function setHUD() {
      hudScore.textContent = state.elapsed.toFixed(2) + 's';
      hudHi.textContent = 'Best: ' + state.best.toFixed(2) + 's';
    }

    function toast(msg) {
      const div = document.createElement('div');
      div.className = 'toast';
      div.textContent = msg;
      toasts.appendChild(div);
      setTimeout(() => { div.style.opacity = '0'; div.style.transform = 'translateY(8px)'; }, 1600);
      setTimeout(() => div.remove(), 2200);
    }

    function unlock(name, label) {
      if (state.achievements[name]) return;
      state.achievements[name] = true;
      store.set('mmm.ach', state.achievements);
      toast('Achievement unlocked: ' + label + ' ðŸŽ‰');
      audio.ach();
    }

    function resetGame() {
      state.enemies.length = 0;
      state.obstacles.length = 0;
      state.trail.length = 0;
      state.spawnTimer = 0;
      state.bgScrollY = 0;
      state.elapsed = 0;
      state.dead = false;
      state.running = false;
      state.finger.alive = false;
      state.lastFrame = performance.now();
      state.nextWaveIn = rnd(2, 5);
      state.waveTimer = 0;
      state.entities.length = 0;
      setHUD();
    }

    function startRun() {
      resetGame();
      hide(startOverlay);
      hide(gameOverOverlay);
      state.running = true;
      state.startTime = performance.now();
      state.finger.alive = true;
      audio.start();
    }

    function endRun(reason) {
      if (state.dead) return;
      state.dead = true;
      state.running = false;
      state.best = Math.max(state.best, state.elapsed);
      store.set('mmm.best', state.best);
      finalScore.textContent = 'You survived ' + state.elapsed.toFixed(2) + 's';
      if (navigator.vibrate) navigator.vibrate(50);
      show(gameOverOverlay);
      setHUD();
      audio.hit(); try { if (bgMusic) { bgMusic.pause(); bgMusic.currentTime = 0; } } catch(e) {}
      if (reason === 'lift') toast("Don't lift your finger!");
      if (state.elapsed >= 5) unlock('s5', '5 Seconds');
      if (state.elapsed >= 10) unlock('s10', '10 Seconds');
      if (state.elapsed >= 20) unlock('s20', '20 Seconds');
    }

    function rnd(min, max) { return Math.random() * (max - min) + min; }
    function irnd(min, max) { return Math.floor(rnd(min, max + 1)); }

    function levelFromTime(t) { return Math.max(1, Math.floor(t / 6) + 1); }

    function generateEnemy(level) {
      const W = canvas.clientWidth; const H = canvas.clientHeight;
      const enemy = { kind: 'enemy' };
      if (level < 3) {
        enemy.movement_pattern = Math.random() < 0.5 ? 'linear_horizontal' : 'linear_vertical';
      } else if (level < 6) {
        const pool = ['linear_horizontal','linear_vertical','oscillating_sine','random'];
        enemy.movement_pattern = pool[irnd(0, pool.length - 1)];
      } else {
        const pool = ['linear_horizontal','linear_vertical','oscillating_sine','rotational','tracking','random'];
        enemy.movement_pattern = pool[irnd(0, pool.length - 1)];
      }
      enemy.speed = rnd(0.5 + level * 0.1, 2.0 + level * 0.2);
      enemy.movement_range = rnd(50, 150 + level * 10);
      enemy.x = rnd(0, W);
      enemy.y = rnd(0, H);
      enemy.start_x = enemy.x;
      enemy.start_y = enemy.y;
      enemy.r = rnd(14, 20);
      if (enemy.movement_pattern === 'rotational') {
        enemy.pivot_x = rnd(0, W);
        enemy.pivot_y = rnd(0, H);
        enemy.angle = rnd(0, Math.PI * 2);
      }
      if (enemy.movement_pattern === 'random') {
        enemy.dirAngle = rnd(0, Math.PI * 2);
        enemy.nextDirChange = performance.now() / 1000 + rnd(1.2, 2.4);
      }
      return enemy;
    }

    function allowedPatternsByLevel(level) {
      if (level < 4) return ['linear_horizontal'];
      if (level < 7) return ['linear_horizontal','oscillating_sine','random'];
      return ['linear_horizontal','oscillating_sine','rotational','tracking','random'];
    }

    function spawnEnemyGroup(level) {
      const W = canvas.clientWidth;
      const patterns = allowedPatternsByLevel(level);
      const group_pattern = patterns[irnd(0, patterns.length - 1)];
      const BASE_FALL = 80;
      const fall_speed = BASE_FALL + level * 12;
      const maxByLevel = Math.min(8, 5 + Math.floor(level / 2));
      const enemy_count = irnd(3, Math.max(3, maxByLevel));
      const groupCenter = rnd(40, Math.max(40, W - 40));
      const spacing = 26;
      const enemies = [];
      for (let i = 0; i < enemy_count; i++) {
        const e = { kind: 'enemy' };
        e.pattern = group_pattern;
        e.hSpeed = rnd(0.8 + level * 0.05, 1.8 + level * 0.1);
        e.movement_range = rnd(40, 120 + level * 6);
        const offset = (i - (enemy_count - 1) / 2) * spacing + rnd(-8, 8);
        e.x = Math.max(12, Math.min(W - 12, groupCenter + offset));
        e.y = -50 + rnd(-20, 0);
        e.start_x = e.x;
        e.start_y = e.y;
        e.fall_speed = fall_speed;
        e.r = rnd(14, 20);
        if (e.pattern === 'rotational') {
          e.pivot_x = e.start_x;
          e.pivot_y = e.start_y;
          e.angle = rnd(0, Math.PI * 2);
        }
        if (e.pattern === 'random') {
          e.vx = rnd(-1, 1) * (40 + level * 6);
          e.nextDirChange = performance.now() / 1000 + rnd(0.8, 1.6);
        }
        enemies.push(e);
      }
      return enemies;
    }

    function enemyTypesByLevel(level) {
      if (level < 3) return ['basic_enemy'];
      if (level < 5) return ['basic_enemy','fast_enemy'];
      if (level < 7) return ['basic_enemy','fast_enemy','chaser_enemy'];
      if (level < 9) return ['basic_enemy','fast_enemy','chaser_enemy','spinning_enemy'];
      return ['basic_enemy','fast_enemy','chaser_enemy','spinning_enemy','swarm_enemy'];
    }

    function obstacleTypesByLevel(level) {
      if (level < 4) return ['spike_block'];
      if (level < 7) return ['spike_block','moving_wall'];
      if (level < 9) return ['spike_block','moving_wall','rotating_blade'];
      return ['spike_block','moving_wall','rotating_blade','trap_zone'];
    }

    function createEnemy(level, pattern, fallSpeed) {
      const W = canvas.clientWidth;
      const enemy = { kind: 'enemy' };
      enemy.pattern = pattern;
      const types = enemyTypesByLevel(level);
      enemy.type = types[irnd(0, types.length - 1)];
      enemy.x = rnd(12, Math.max(12, W - 12));
      enemy.y = -50;
      enemy.fall_speed = fallSpeed;
      enemy.r = rnd(14, 20);
      enemy.start_x = enemy.x; enemy.start_y = enemy.y;
      enemy.hSpeed = rnd(0.8 + level * 0.05, 1.8 + level * 0.1);
      enemy.movement_range = rnd(40, 110 + level * 6);
      if (enemy.type === 'fast_enemy') enemy.fall_speed *= 1.3;
      if (enemy.type === 'spinning_enemy' || enemy.pattern === 'rotational') {
        enemy.pivot_x = enemy.x; enemy.pivot_y = enemy.y; enemy.angle = rnd(0, Math.PI * 2);
      }
      if (enemy.type === 'chaser_enemy' || enemy.pattern === 'tracking') {
        enemy.trackFactor = 30 + level * 3;
      }
      if (enemy.type === 'swarm_enemy') {
        enemy.r = rnd(10, 14); enemy.swarmSpread = rnd(20, 40);
      }
      if (enemy.pattern === 'random') {
        enemy.vx = rnd(-1, 1) * (40 + level * 6); enemy.nextDirChange = performance.now()/1000 + rnd(0.8, 1.6);
      }
      return enemy;
    }

    function createObstacle(level, pattern, fallSpeed) {
      const W = canvas.clientWidth;
      const ob = { kind: 'obstacle' };
      ob.pattern = pattern;
      const types = obstacleTypesByLevel(level);
      ob.type = types[irnd(0, types.length - 1)];
      ob.x = rnd(18, Math.max(18, W - 18));
      ob.y = -50;
      ob.fall_speed = fallSpeed;
      if (ob.type === 'spike_block') { ob.w = rnd(28, 42); ob.h = ob.w; ob.r = ob.w * 0.6; }
      if (ob.type === 'moving_wall') {
        ob.axis = Math.random() < 0.5 ? 'horizontal' : 'vertical';
        ob.w = ob.axis === 'horizontal' ? rnd(120, 200) : rnd(26, 38);
        ob.h = ob.axis === 'vertical' ? rnd(120, 200) : rnd(26, 38);
        ob.range = rnd(50, 150); ob.start_x = ob.x; ob.start_y = ob.y; ob.speed = rnd(0.5, 1.5 + level * 0.1);
      }
      if (ob.type === 'rotating_blade') {
        ob.pivot_x = ob.x; ob.pivot_y = ob.y; ob.radius = rnd(50, 90); ob.angle = rnd(0, Math.PI*2); ob.rotation_speed = rnd(0.5, 1.5 + level * 0.1); ob.blade_r = 16;
      }
      if (ob.type === 'trap_zone') {
        ob.active_time = rnd(1, 3); ob.inactive_time = rnd(1, 3); ob.cycle = ob.active_time + ob.inactive_time; ob.start_t = performance.now()/1000; ob.w = rnd(80, 120); ob.h = rnd(80, 120);
      }
      if (pattern === 'random') { ob.vx = rnd(-1, 1) * (40 + level * 6); ob.nextDirChange = performance.now()/1000 + rnd(0.8, 1.6); }
      return ob;
    }

    function spawnWave(level) {
      const patterns = allowedPatternsByLevel(level);
      const wave_pattern = patterns[irnd(0, patterns.length - 1)];
      const BASE_FALL_SPEED = 80;
      const fall_speed = BASE_FALL_SPEED + level * 12;
      const wave_size = irnd(3, Math.min(8, 5 + Math.floor(level/2)));
      const items = [];
      const formationRoll = Math.random();
      const W = canvas.clientWidth; const centerX = rnd(60, Math.max(60, W - 60));
      if (formationRoll < 0.45) {
        const cols = Math.random() < 0.5 ? 2 : 3;
        const rows = 3;
        const spacing = 56;
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const spawnEnemy = Math.random() < 0.7;
            const x = centerX + (c - (cols - 1)/2) * spacing + rnd(-6, 6);
            const y = -50 - r * spacing * 0.9 + rnd(-6, 6);
            if (spawnEnemy) { const e = createEnemy(level, wave_pattern, fall_speed); e.x = Math.max(12, Math.min(W-12, x)); e.y = y; e.start_x = e.x; e.start_y = e.y; items.push(e); }
            else { const o = createObstacle(level, wave_pattern, fall_speed); o.x = Math.max(18, Math.min(W-18, x)); o.y = y; if (o.start_x==null) o.start_x=o.x; if (o.start_y==null) o.start_y=o.y; items.push(o); }
          }
        }
      } else if (formationRoll < 0.75) {
        for (let i = 0; i < wave_size; i++) { const o = createObstacle(level, 'linear_horizontal', fall_speed); o.type = Math.random()<0.5?'moving_wall':'rotating_blade'; o.x = rnd(40, W-40); o.y = -50 - i*30; if (o.start_x==null) o.start_x=o.x; if (o.start_y==null) o.start_y=o.y; items.push(o); }
      } else {
        for (let i = 0; i < wave_size; i++) { if (Math.random()<0.5) items.push(createEnemy(level, wave_pattern, fall_speed)); else items.push(createObstacle(level, wave_pattern, fall_speed)); }
      }
      return items;
    }

    function generateObstacle(level) {
      const W = canvas.clientWidth; const H = canvas.clientHeight;
      const obstacle = { kind: 'obstacle' };
      let allowed = ['spike'];
      if (level >= 4 && level <= 6) allowed = ['spike','moving_wall'];
      if (level >= 7) allowed = ['spike','moving_wall','rotating_blade','trap_zone'];
      obstacle.type = allowed[irnd(0, allowed.length - 1)];
      obstacle.x = rnd(0, W);
      obstacle.y = rnd(0, H);
      if (obstacle.type === 'moving_wall') {
        obstacle.axis = Math.random() < 0.5 ? 'horizontal' : 'vertical';
        obstacle.speed = rnd(0.5, 1.5 + level * 0.1);
        obstacle.range = rnd(50, 150);
        obstacle.w = obstacle.axis === 'horizontal' ? rnd(120, 200) : rnd(26, 38);
        obstacle.h = obstacle.axis === 'vertical' ? rnd(120, 200) : rnd(26, 38);
        obstacle.start_x = obstacle.x; obstacle.start_y = obstacle.y;
        obstacle.r = Math.max(obstacle.w, obstacle.h) * 0.5;
      } else if (obstacle.type === 'rotating_blade') {
        obstacle.pivot_x = rnd(0, W);
        obstacle.pivot_y = rnd(0, H);
        obstacle.rotation_speed = rnd(0.5, 1.5 + level * 0.1);
        obstacle.radius = rnd(50, 100);
        obstacle.blade_r = 16;
        obstacle.angle = rnd(0, Math.PI * 2);
      } else if (obstacle.type === 'trap_zone') {
        obstacle.active_time = rnd(1, 3);
        obstacle.inactive_time = rnd(1, 3);
        obstacle.cycle = obstacle.active_time + obstacle.inactive_time;
        obstacle.w = rnd(80, 120);
        obstacle.h = rnd(80, 120);
        obstacle.start_t = performance.now() / 1000;
      } else if (obstacle.type === 'spike') {
        obstacle.r = rnd(16, 26);
      }
      return obstacle;
    }

    function updateEnemy(enemy, dt, timeSec, player) {
      const W = canvas.clientWidth; const H = canvas.clientHeight;
      const hs = enemy.hSpeed || enemy.speed || 1.2;
      const isRot = (enemy.pattern === 'rotational' || enemy.movement_pattern === 'rotational');
      if (!isRot) enemy.y += (enemy.fall_speed || 80) * dt;
      if (enemy.pattern === 'linear_horizontal' || enemy.movement_pattern === 'linear_horizontal') {
        const startX = enemy.start_x != null ? enemy.start_x : enemy.x;
        enemy.x = startX + Math.sin(timeSec * hs) * (enemy.movement_range || 80);
      } else if (enemy.pattern === 'oscillating_sine' || enemy.movement_pattern === 'oscillating_sine') {
        const startX = enemy.start_x != null ? enemy.start_x : enemy.x;
        enemy.x = startX + Math.sin(timeSec * hs) * (enemy.movement_range || 90);
      } else if (enemy.pattern === 'rotational' || enemy.movement_pattern === 'rotational') {
        enemy.angle = (enemy.angle || 0) + hs * dt;
        enemy.pivot_y = (enemy.pivot_y != null ? enemy.pivot_y : enemy.y) + (enemy.fall_speed || 80) * dt;
        const px = enemy.pivot_x != null ? enemy.pivot_x : enemy.x;
        const py = enemy.pivot_y;
        enemy.x = px + Math.cos(enemy.angle) * (enemy.movement_range || 60);
        enemy.y = py + Math.sin(enemy.angle) * (enemy.movement_range || 60);
      } else if (enemy.pattern === 'tracking' || enemy.movement_pattern === 'tracking') {
        const dx = player.x - enemy.x; const d = Math.abs(dx) || 1;
        const ux = dx / d; const s = hs * 40 * dt;
        enemy.x += ux * s;
      } else if (enemy.pattern === 'random' || enemy.movement_pattern === 'random') {
        if (timeSec >= (enemy.nextDirChange || 0)) {
          const sgn = Math.random() < 0.5 ? -1 : 1; enemy.vx = sgn * (40 + hs * 20);
          enemy.nextDirChange = timeSec + rnd(0.8, 1.6);
        }
        enemy.x += (enemy.vx || 0) * dt;
      }
      if (enemy.x < enemy.r) enemy.x = enemy.r; if (enemy.x > W - enemy.r) enemy.x = W - enemy.r;
      if (enemy.y < -60) enemy.y = -60;
    }

    function isTrapActive(ob, timeSec) {
      if (ob.type !== 'trap_zone') return true;
      const t = (timeSec - (ob.start_t || 0)) % (ob.cycle || 1);
      return t < (ob.active_time || 0);
    }

    function updateObstacle(ob, dt, timeSec) {
      if (ob.type === 'moving_wall') {
        if (ob.axis === 'horizontal') {
          ob.x = ob.start_x + Math.sin(timeSec * ob.speed) * ob.range;
        } else {
          ob.y = ob.start_y + Math.sin(timeSec * ob.speed) * ob.range;
        }
      } else if (ob.type === 'rotating_blade') {
        ob.angle += ob.rotation_speed * dt;
      }
    }

    function drawBackdrop(dtMs) {
      const w = canvas.clientWidth, h = canvas.clientHeight;
      state.bgScrollY += (state.bgSpeed * 0.15) * (dtMs / 1000);

      ctx.save();
      ctx.globalAlpha = 0.15;
      ctx.fillStyle = '#ffffff';
      const stripe = 140;
      const off = -state.bgScrollY % stripe;
      for (let y = -stripe + off; y < h + stripe; y += stripe) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y + stripe);
        ctx.lineTo(w, y + stripe - 18);
        ctx.lineTo(0, y - 18);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();

      ctx.save();
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = 'rgba(0,0,0,.2)';
      const gap = 52; const offY = state.bgScrollY % gap;
      for (let y = -gap + offY; y < h + gap; y += gap) {
        ctx.beginPath(); ctx.arc(12, y, 5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(w - 12, y + 18, 5, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();

      // dotted background columns
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = 'rgba(0,0,0,.18)';
      const colGap = 60; const rowGap = 48; const yOff = (state.bgScrollY * 0.6) % rowGap;
      for (let x = colGap; x < w - colGap; x += colGap) {
        for (let y = -rowGap + yOff; y < h + rowGap; y += rowGap) {
          ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI*2); ctx.fill();
        }
      }
      ctx.restore();

      const base = h - 40;
      ctx.save();
      ctx.translate(0, (state.bgScrollY * 0.2) % h);
      ctx.fillStyle = '#7bd67b';
      ctx.beginPath();
      ctx.moveTo(-100, base);
      for (let i = -2; i < 6; i++) {
        const cx = i * 160 + 80;
        ctx.quadraticCurveTo(cx - 60, base - 40, cx, base);
        ctx.quadraticCurveTo(cx + 60, base + 40, cx + 120, base);
      }
      ctx.lineTo(w + 100, h + 100); ctx.lineTo(-100, h + 100); ctx.closePath(); ctx.fill();
      ctx.restore();

      // side spike rails
      drawSideRails(w, h, state.bgScrollY);
    }

    function drawSideRails(w, h, scroll) {
      const spikeGap = 48; const off = scroll % spikeGap; const edgeX = RAIL_W - 6;
      ctx.save(); ctx.fillStyle = '#ff9f3b'; ctx.strokeStyle = '#2b1b00'; ctx.lineWidth = 2;
      for (let y = -spikeGap + off; y < h + spikeGap; y += spikeGap) {
        ctx.beginPath(); ctx.moveTo(RAIL_W, y); ctx.lineTo(edgeX, y + 14); ctx.lineTo(RAIL_W, y + 28); ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(w - RAIL_W, y); ctx.lineTo(w - edgeX, y + 14); ctx.lineTo(w - RAIL_W, y + 28); ctx.closePath(); ctx.fill(); ctx.stroke();
      }
      ctx.restore();
    }

    function drawEnemySquare(e) {
      const r = e.r; const inner = r; const outer = r * 1.2;
      ctx.save(); ctx.translate(e.x, e.y);
      ctx.beginPath();
      for (let i = 0; i < 8; i++) {
        const a = (i / 8) * Math.PI * 2 + Math.PI/8;
        const px = Math.cos(a) * outer; const py = Math.sin(a) * outer;
        ctx.lineTo(px, py);
      }
      ctx.closePath(); ctx.fillStyle = '#ff6b7a'; ctx.strokeStyle = 'rgba(0,0,0,.35)'; ctx.lineWidth = 2; ctx.fill(); ctx.stroke();
      ctx.fillStyle = '#e33949'; ctx.beginPath(); ctx.rect(-inner, -inner, inner*2, inner*2); ctx.fill();
      ctx.fillStyle = '#10131a'; ctx.beginPath(); ctx.arc(-r*0.35, -r*0.1, r*0.28, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(r*0.35, -r*0.1, r*0.28, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    function drawEnemyBall(e) {
      const spikes = 12; const inner = e.r * 0.65; const outer = e.r;
      ctx.save(); ctx.translate(e.x, e.y);
      ctx.beginPath();
      for (let i = 0; i < spikes * 2; i++) {
        const rad = (i % 2 === 0) ? outer : inner;
        const a = (i / (spikes * 2)) * Math.PI * 2;
        const px = Math.cos(a) * rad; const py = Math.sin(a) * rad;
        if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
      }
      ctx.closePath();
      const grad = ctx.createRadialGradient(0,0, inner*0.2, 0,0, outer);
      grad.addColorStop(0, '#9df78c'); grad.addColorStop(1, '#3aa63a');
      ctx.fillStyle = grad; ctx.strokeStyle = 'rgba(0,0,0,.35)'; ctx.lineWidth = 2; ctx.fill(); ctx.stroke();
      ctx.restore();
    }

    function drawEnemy(e) {
      if (e.type === 'basic_enemy') return drawEnemySquare(e);
      return drawEnemyBall(e);
    }

    function drawObstacle(ob, timeSec) {
      if (ob.type === 'spike_block') {
        ctx.save();
        ctx.translate(ob.x, ob.y);
        const w = ob.w || 36, h = ob.h || w;
        ctx.fillStyle = '#e6e6e6'; ctx.strokeStyle = 'rgba(0,0,0,.35)'; ctx.lineWidth = 2;
        roundRect(ctx, -w/2, -h/2, w, h, 8); ctx.fill(); ctx.stroke();
        ctx.restore();
      } else if (ob.type === 'moving_wall') {
        ctx.save();
        ctx.translate(ob.x, ob.y);
        ctx.fillStyle = '#ffcf59'; ctx.strokeStyle = '#2b1b00'; ctx.lineWidth = 2;
        roundRect(ctx, -ob.w/2, -ob.h/2, ob.w, ob.h, Math.min(ob.w, ob.h) * 0.45);
        ctx.fill(); ctx.stroke();
        // edge spikes along the long sides
        ctx.fillStyle = '#2b1b00';
        const step = 16; const half = ob.w/2; const halfH = ob.h/2; const dirLong = ob.w > ob.h;
        if (dirLong) {
          for (let x = -half + step; x < half - step; x += step) {
            ctx.beginPath(); ctx.moveTo(x, -halfH - 2); ctx.lineTo(x + 6, -halfH - 12); ctx.lineTo(x + 12, -halfH - 2); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(x, halfH + 2); ctx.lineTo(x + 6, halfH + 12); ctx.lineTo(x + 12, halfH + 2); ctx.closePath(); ctx.fill();
          }
        } else {
          for (let y = -halfH + step; y < halfH - step; y += step) {
            ctx.beginPath(); ctx.moveTo(-half - 2, y); ctx.lineTo(-half - 12, y + 6); ctx.lineTo(-half - 2, y + 12); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(half + 2, y); ctx.lineTo(half + 12, y + 6); ctx.lineTo(half + 2, y + 12); ctx.closePath(); ctx.fill();
          }
        }
        ctx.restore();
      } else if (ob.type === 'rotating_blade') {
        const bx = ob.pivot_x + Math.cos(ob.angle) * ob.radius;
        const by = ob.pivot_y + Math.sin(ob.angle) * ob.radius;
        ctx.save();
        ctx.translate(ob.pivot_x, ob.pivot_y);
        ctx.strokeStyle = 'rgba(0,0,0,.25)'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(bx - ob.pivot_x, by - ob.pivot_y); ctx.stroke();
        ctx.restore();
        ctx.save();
        ctx.translate(bx, by);
        ctx.rotate(ob.angle * 3);
        ctx.fillStyle = '#c4c9d4'; ctx.strokeStyle = 'rgba(0,0,0,.35)'; ctx.lineWidth = 2;
        for (let i = 0; i < 4; i++) {
          ctx.rotate(Math.PI / 2);
          ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(ob.blade_r*1.2, -4); ctx.lineTo(ob.blade_r*1.2, 4); ctx.closePath(); ctx.fill(); ctx.stroke();
        }
        ctx.beginPath(); ctx.fillStyle = '#9aa3b2'; ctx.arc(0, 0, 6, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      } else if (ob.type === 'trap_zone') {
        const active = isTrapActive(ob, timeSec);
        ctx.save();
        ctx.translate(ob.x, ob.y);
        ctx.fillStyle = active ? 'rgba(255,77,79,0.65)' : 'rgba(0,0,0,0.12)';
        ctx.strokeStyle = active ? 'rgba(255,77,79,1)' : 'rgba(0,0,0,0.25)';
        ctx.lineWidth = 2;
        roundRect(ctx, -ob.w/2, -ob.h/2, ob.w, ob.h, 12);
        ctx.fill(); ctx.stroke();
        ctx.restore();
      }
    }

    function drawFinger(dt) {
      const f = state.finger;
      const ease = 1 - Math.pow(0.001, dt/16.67);
      f.trailX += (f.x - f.trailX) * ease;
      f.trailY += (f.y - f.trailY) * ease;

      if (state.touchActive) {
        state.trail.push({ x: f.trailX, y: f.trailY, t: performance.now() });
        if (state.trail.length > 60) state.trail.shift();
      }
      const now = performance.now();
      for (let i = 0; i < state.trail.length; i++) {
        const p = state.trail[i];
        const age = (now - p.t) / 1000;
        const alpha = Math.max(0, 1 - age * 1.5);
        if (alpha <= 0) continue;
        ctx.globalAlpha = alpha * 0.35;
        ctx.fillStyle = '#1f6fff';
        ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
      }

      ctx.save(); ctx.shadowColor = 'rgba(0,0,0,.35)'; ctx.shadowBlur = 16;
      const grad = ctx.createRadialGradient(f.trailX - f.r*0.25, f.trailY - f.r*0.25, f.r*0.25, f.trailX, f.trailY, f.r);
      grad.addColorStop(0, '#ffeeaa'); grad.addColorStop(1, '#ff8f2e');
      ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(f.trailX, f.trailY, f.r, 0, Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0; ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(0,0,0,.25)'; ctx.stroke();
    }

    function collideCircleCircle(ax, ay, ar, bx, by, br) {
      const dx = ax - bx, dy = ay - by; const r = ar + br; return dx*dx + dy*dy <= r*r;
    }

    function collideCircleRect(cx, cy, cr, rx, ry, rw, rh) {
      const hx = rw / 2, hy = rh / 2; const nx = Math.max(rx - hx, Math.min(cx, rx + hx)); const ny = Math.max(ry - hy, Math.min(cy, ry + hy));
      const dx = cx - nx, dy = cy - ny; return dx*dx + dy*dy <= cr*cr;
    }

    function applyPattern(entity, dt, timeSec, player) {
      const hs = entity.hSpeed || entity.speed || 1.2;
      if (entity.pattern === 'linear_horizontal') {
        const startX = entity.start_x != null ? entity.start_x : entity.x;
        entity.x = startX + Math.sin(timeSec * hs) * (entity.movement_range || 80);
      } else if (entity.pattern === 'oscillating_sine') {
        const startX = entity.start_x != null ? entity.start_x : entity.x;
        entity.x = startX + Math.sin(timeSec * hs) * (entity.movement_range || 90);
      } else if (entity.pattern === 'rotational') {
        entity.angle = (entity.angle || 0) + hs * dt;
        entity.pivot_y = (entity.pivot_y != null ? entity.pivot_y : entity.y) + (entity.fall_speed || 80) * dt;
        const px = entity.pivot_x != null ? entity.pivot_x : entity.x;
        const py = entity.pivot_y;
        entity.x = px + Math.cos(entity.angle) * (entity.movement_range || 60);
        entity.y = py + Math.sin(entity.angle) * (entity.movement_range || 60);
      } else if (entity.pattern === 'tracking') {
        const dx = (player.x) - entity.x; const ux = dx / (Math.abs(dx) || 1);
        entity.x += ux * (30 + (hs*10)) * dt;
      } else if (entity.pattern === 'random') {
        if (timeSec >= (entity.nextDirChange || 0)) { const sgn = Math.random() < 0.5 ? -1 : 1; entity.vx = sgn * (40 + hs * 20); entity.nextDirChange = timeSec + rnd(0.8, 1.6); }
        entity.x += (entity.vx || 0) * dt;
      }
      if (entity.type === 'moving_wall') {
        entity.x = (entity.start_x || entity.x) + Math.sin(timeSec * (entity.speed || 1)) * (entity.range || 80);
      } else if (entity.type === 'rotating_blade') {
        entity.angle = (entity.angle || 0) + (entity.rotation_speed || 1) * dt;
      } else if (entity.type === 'chaser_enemy') {
        const dx = (player.x) - entity.x; const ux = dx / (Math.abs(dx) || 1); entity.x += ux * (entity.trackFactor || 30) * dt;
      }
    }

    function updateEntity(ent, dt, timeSec, player) {
      ent.y += (ent.fall_speed || 80) * dt;
      applyPattern(ent, dt, timeSec, player);
    }

    function updateGame(dtMs, timeSec) {
      const dt = dtMs / 1000;
      const level = levelFromTime(state.elapsed);
      state.waveTimer += dt;
      if (state.waveTimer >= state.nextWaveIn) {
        const wave = spawnWave(level);
        for (let i = 0; i < wave.length; i++) state.entities.push(wave[i]);
        state.waveTimer = 0; state.nextWaveIn = rnd(2, 5);
      }

      const player = { x: state.finger.trailX || state.finger.x, y: state.finger.trailY || state.finger.y };

      // wall rails collision
      const px = player.x; if (px < RAIL_W || px > (canvas.clientWidth - RAIL_W)) { endRun('hit'); return; }

      const H = canvas.clientHeight;
      for (let i = state.entities.length - 1; i >= 0; i--) {
        const it = state.entities[i];
        updateEntity(it, dt, timeSec, player);
        let off = false;
        if (it.kind === 'enemy') off = (it.y - (it.r || 0) > H + 40);
        else { const h = it.h || (it.r || 20) * 2; off = (it.y - h/2 > H + 40); }
        if (off || !Number.isFinite(it.x) || !Number.isFinite(it.y)) { state.entities.splice(i, 1); continue; }
        if (!state.running) continue;
        let hit = false;
        if (it.kind === 'enemy') {
          hit = collideCircleCircle(player.x, player.y, state.finger.r * 0.9, it.x, it.y, it.r || 16);
        } else if (it.type === 'moving_wall') {
          hit = collideCircleRect(player.x, player.y, state.finger.r * 0.9, it.x, it.y, it.w, it.h);
        } else if (it.type === 'rotating_blade') {
          const bx = (it.pivot_x || it.x) + Math.cos(it.angle || 0) * (it.radius || 60);
          const by = (it.pivot_y || it.y) + Math.sin(it.angle || 0) * (it.radius || 60);
          hit = collideCircleCircle(player.x, player.y, state.finger.r * 0.9, bx, by, it.blade_r || 16);
        } else if (it.type === 'trap_zone') {
          const active = isTrapActive(it, timeSec);
          if (active) hit = collideCircleRect(player.x, player.y, state.finger.r * 0.9, it.x, it.y, it.w, it.h);
        } else if (it.type === 'spike_block') {
          hit = collideCircleRect(player.x, player.y, state.finger.r * 0.9, it.x, it.y, it.w, it.h);
        }
        if (hit) { endRun('hit'); break; }
      }
    }

    function step(t) {
      const now = t; const dt = Math.min(34, now - (state.lastFrame || now)); state.lastFrame = now;
      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
      drawBackdrop(dt);

      for (let i = 0; i < state.entities.length; i++) {
        const it = state.entities[i];
        if (it.kind === 'enemy') drawEnemy(it); else drawObstacle(it, now / 1000);
      }

      if (state.finger.alive) drawFinger(dt);

      if (state.running) {
        updateGame(dt, now / 1000);
        state.elapsed = (now - state.startTime) / 1000; setHUD();
        ctx.save(); ctx.font = '900 40px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif'; ctx.textAlign = 'center'; ctx.lineWidth = 6; ctx.lineJoin = 'round';
        ctx.strokeStyle = 'rgba(0,0,0,.35)'; ctx.strokeText(Math.floor(state.elapsed * 100).toString(), canvas.clientWidth/2, 60);
        ctx.fillStyle = '#184c0e'; ctx.fillText(Math.floor(state.elapsed * 100).toString(), canvas.clientWidth/2, 60); ctx.restore();
      }

      requestAnimationFrame(step);
    }

    requestAnimationFrame(step);

    function updateFingerFromEvent(ev) {
      const rect = canvas.getBoundingClientRect();
      const t = (ev.touches && ev.touches[0]) || (ev.changedTouches && ev.changedTouches[0]) || ev;
      const x = (t.clientX - rect.left); const y = (t.clientY - rect.top);
      state.finger.x = x; state.finger.y = y;
      if (!state.finger.trailX && !state.finger.trailY) { state.finger.trailX = x; state.finger.trailY = y; }
    }

    function onPress(ev) { ev.preventDefault(); state.touchActive = true; audio.init(); try { if (bgMusic) { bgMusic.loop = true; if (bgMusic.paused) { bgMusic.volume = 0.25; bgMusic.play().catch(() => {}); } } } catch(e) {} updateFingerFromEvent(ev); if (!state.running && !state.dead) startRun(); if (state.dead) { resetGame(); startRun(); } }
    function onMove(ev) { ev.preventDefault(); if (!state.touchActive) return; updateFingerFromEvent(ev); }
    function onRelease(ev) { ev.preventDefault(); state.touchActive = false; if (state.running) endRun('lift'); }

    canvas.addEventListener('touchstart', onPress, { passive: false });
    canvas.addEventListener('touchmove', onMove, { passive: false });
    canvas.addEventListener('touchend', onRelease, { passive: false });
    canvas.addEventListener('touchcancel', onRelease, { passive: false });
    canvas.addEventListener('mousedown', onPress); window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onRelease);

    tapToStart.addEventListener('click', () => { hide(startOverlay); toast('Hold to play'); });
    howToPlay.addEventListener('click', () => { toast('Hold your finger on the screen and avoid the chompers!'); });
    retryBtn.addEventListener('click', () => { hide(gameOverOverlay); toast('Hold to start'); });
    shareBtn.addEventListener('click', async () => {
      const text = 'I survived ' + state.best.toFixed(2) + 's in MMM Fingers!';
      try { if (navigator.share) await navigator.share({ text, title: 'MMM Fingers' }); else { await navigator.clipboard.writeText(text); toast('Copied to clipboard'); } } catch {}
    });

    setHUD(); if (state.best > 0) toast('Best: ' + state.best.toFixed(2) + 's');

    function roundRect(ctx, x, y, width, height, radius) {
      radius = Math.min(radius, width/2, height/2);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.arcTo(x + width, y, x + width, y + height, radius);
      ctx.arcTo(x + width, y + height, x, y + height, radius);
      ctx.arcTo(x, y + height, x, y, radius);
      ctx.arcTo(x, y, x + width, y, radius);
      ctx.closePath();
    }
  })();
  </script>
</body>
</html>
